解决依赖
sudo apt-get -f install

1:rpm包
安装 rpm -ivh soft.version.rpm;
卸载 rpm -e software

2:dpkg包

安装dpkg -i soft.version.deb
卸载dpkg -e software
查询当前系统安装的软件包  dpkg -l

3:tar.gz源代码包安装方式
1) 找到相应的软件包，比如soft.tar.gz，下载到本机某个目录；
2) 打开一个终端，su 成root用户;
3) cd soft.tar.gz所在的目录;
4) tar -xzvf soft.tar.gz;  / tar -xjvf soft.tar.bz2;
5) cd soft;
6) ./configure    为编译做好准备，对即将安装的软件进行配置，检查当前的环境是否满足要安装软件的依赖关系，将生成makefile文件。
7) make         进行软件编译。 
8) make install  完成安装
9) make clean   删除安装时产生的临时文件
最好是看这个软件的install和readme文件，一般会说明该软件的可执行文件存放在哪里，一般是放在/usr/local/bin目录下。
如果软件里面没有config这个文件，那么你下载的是二进制文件，可以直接使用。

4:apt
 apt-get -d install packagename 仅下载不安装
 apt-cache search soft 注：soft是你要找的软件的名称或相关信息(针对本地数据进行相关操作的工具)
 apt-get install soft.version安装
2) apt-cache search soft 注：soft是你要找的软件的名称或相关信息
3) 如果2中找到了软件soft.version，则可用apt-get install soft.version安装
详细介绍：
apt-get是debian，ubuntu发行版本的包管理工具，与红帽中的yum工具非常相似,它一般需要root权限执行，所以一般要跟着sudo命令。
apt-get install packagename 安装一个新软件包
apt-get remove packagename  卸载一个已安装的软件包（保留配置文件）
apt-get autoremove packagename 移除之前被其他软件包依赖,但现在不再被使用的软件包
apt-get purge packagename 不保留配置文件的移除
apt-get --purge remove packagename  卸载一个已安装的软件包（删除配置文件）
dpkg --force-all --purge packagename   有些软件比较难卸载，而且还阻止了别的软件的应用，就可以用这个
apt-get autoremove  因为apt会把已装或已卸的软件都备份在硬盘上，所以如果需要空间的话，可以这个命令来删除你已经删除的软件。


apt-get clean:
apt-get安装的软件包会存储在/var/cache/apt/archives/和/var/cache/apt/archives/partial/两个目录下，长期使用会占用硬盘空间。clean指令就是删除掉这两个目录中的软件包，除了已经被锁定的文件。
apt-get autoclean:
同样是这两个目录下的软件包，不同的是autoclean只删除不能被再次下载的软件包，所以说apt-get clean删除清理更彻底。

apt-get upgrade 更新所有已安装的软件包。
apt-get dist-upgrade 将系统升级到新版本。
apt-cache search string  在软件列表中搜索字符串
apt-cache showpkg pkgs  显示软件包信息
apt-cache stats  查看库里有多少软件
apt-cache packagename  打印软件库里面所有的软件列表

 1.1、安装软件       sudo apt install 软件名

 1.2、卸载软件      sudo  apt remove  软件名

 1.3、访问源列表里的每个网址，并读取软件列表，然后保存在本地电脑      sudo apt  update 

 1.4、更新已安装的包    sudo apt upgrad


dpkg -l |grep 关键词
dpkg -S softwarename 显示包含此软件包的所有位置，dpkg -L softwarename 显示安装路径
dpkg -l softwarename 查看软件版本
      ./configure --prefix=/opt/XXX  
      它用来设置软件的安装目录.
源码包安装:tar zxvf XXXX.tar.gz (or tar jxvf XXXX.tar.bz2)
           cd XXXX
          ./configure
           make
           make install            ##安装
           make clean              ##安装完成后用来清理临时文件
dpkg常用参数介绍：
参数	说明
-i	安装指定deb包
-R	后面加上目录名，用于安装该目录下的所有deb安装包
-r	remove，移除某个已安装的软件包
-I	显示deb包文件的信息
-s	显示已安装软件的信息
-S	搜索已安装的软件包
-L	显示已安装软件包的目录信息



rpm包：
1、rpm包
可以用命令：
rpm:
#查询是否安装某个软件
rpm -qa | grep vim

#查询命令属于哪个软件
rpm -qf  /usr/bin/passwd

#查询文件
rpm -qf /usr/bin
#查询RPM的详细信息
rpm -qpi /mnt/Packages/filesystem-3.2-20.el7.x86_64.rpm 
#rpm –ql 包名           如 rpm -ql gcc 来查看gcc的文件都安装到哪里去了

#rpm -qa | grep 包名   来查看有没有安装这个包 ，

#rpm -qa              查看全部已经安装的包名
#rpm -e 文件名         这个命令就是你想卸载的软件，后面是包名称，最后的版本号是不用打的
yum安装：
yum install 包名  # 安装
yum -y remove 包名  # 卸载
yum list # 列出所有可安裝的软件清单命令

PPA 的一般形式是： ppa:user/ppa-name
添加 PPA 源 
　　添加 PPA 源的命令为：sudo add-apt-repository ppa:user/ppa-name 
　　添加好记得要更新一下： sudo apt-get update
删除 PPA 源 
　　删除 PPA 源的命令格式则为：sudo add-apt-repository -r ppa:user/ppa-name 
　　然后进入 /etc/apt/sources.list.d 目录，将相应 ppa 源的保存文件删除。 
　　最后同样更新一下：sudo apt-get update













记录:Ctrl+r
su切换用户后:在终端输入exit或logout或使用快捷方式ctrl+d，可以退回到原来用户，其实ctrl+d也是执行的exit命令
sudo : 暂时切换到超级用户模式以执行超级用户权限，提示输入密码时该密码为当前用户的密码，而不是超级账户的密码。不过有时间限制，Ubuntu默认为一次时长15分钟。
su ： 切换到某某用户模式，提示输入密码时该密码为切换后账户的密码，用法为“su 账户名称”。如果后面不加账户时系统默认为root账户，密码也为超级账户的密码。没有时间限制。
sudo -i: 为了频繁的执行某些只有超级用户才能执行的权限，而不用每次输入密码，可以使用该命令。提示输入密码时该密码为当前账户的密码。没有时间限制。执行该命令后提示符变为“#”而不是“$”。想退回普通账户时可以执行“exit”或“logout” 。
&  表示任务在后台执行，如要在后台运行redis-server,则有  redis-server &

&& 表示前一条命令执行成功时，才执行后一条命令 ，如 echo '1‘ && echo '2'    

| 表示管道，上一条命令的输出，作为下一条命令参数，如 echo 'yes' | wc -l

|| 表示上一条命令执行失败后，才执行下一条命令，如 cat nofile || echo "fail"
可以

不挂断后台运行
nohup python run.py &不挂断后台运行

远程复制
scp:
-i:   identity_file
scp -r local_folder remote_username@remote_ip:remote_folder #本地到远程
scp remote_username@remote_ip:remote_folder local_folder #远程到本地 

查看发现版本信息
lsb_release -a
cat /etc/issue
cat /etc/xxx-release 
cat /pro/version

curl -d "subject=邮件报警测试&message=这是一个邮件测试2&to_email=cent_yuan@163.com"   http://127.0.0.1:8000/api/sendmail/
nohup python manage.py runserver 0.0.0.0:8001 &

查看文件命令(cat tac nl more less head tail)
cat -n passwd 参数显示行号
head 只查看文件头几行,默认10行
tail 相反显示文件的最后10行
tail -f 这个参数可以不停的读取某个文件内容并显示,可以让我们动态查看日志.

搜索文件命令(whereis which find locate)
     
whereis    查看可执行文件的位置(搜索很快,从数据库中差,不从硬盘中查,只能搜索二进制文件-b man帮助文件-m,和源代码文件 -s) 
locate     配合数据库查看文件位置(快而全,通过/var/lib/mlocate/mlocate.db数据库查找,每天自动更新一次)
它可以用来查找指定目录下的不同文件类型，如查找 /etc 下所有以 sh 开头的文件：
locate /etc/sh
which      通常用来确定是否安装指定的软件,因为只从PATH环境变量制定的路径中取搜索命令
find          实际搜寻硬盘查询文件名称(最强大的,可以通过文件的时间戳,文件的权限)
usage: find [path] 

shell下命令的执行查找顺序:
一般情况下，非登录shell不会执行任何profile文件，非交互shell模式不会执行任何bashrc文件。
1.以相对/绝对路径执行命令，例如：/bin/ls或者./ls
2.由alias命令别名来查找命令
3.由bash内置的（builtin）命令来执行
4.通过$PATH这个环境变量中查找是否有命令的路径
type:
执行 “type -a 命令” 可以查看命令存在于哪里/哪些地方
查找到之后，命令会根据第一个设置来执行
type -a python 

显示目录或文件的大小
du 
usage: du -h /home/centyuan
df -h

压缩打包
zip -r -q -o centyuan.zip /home/centyuan
-r:表示递归打包包含子目录的全部内容
-q:表示为安全模式,即不向屏幕输出信息
-o:表示输出文件,需在其后紧跟打包输出文件名
打包
tar 	-cf centyuan.tar /home/centyuan/Desktop
-c:表示创建一个tar包文件
-f:用于制定文件名
-v:可视的输出打包文件
打包压缩
tar -czf ccentyuan.tar.gz /home/centyuan/Desktop
解包
tar -xf centyuan.tar -C tardir
-x:解包一个文件到指定路径(-C)
解包解压
tar -xzf centyuan.tar.gz
unzip something.zip

cut /etc/passwd -d ':' -f 1,6
#$ 打印/etc/passwd文件中以:为分隔符的第1个字段和第6个字段分别表示用户名和其家目
#cut 打印每一行的某个字段
wc /etc/passwd
#用于统计并输出一个文件中行,单词,字节的数目.简单小巧的计数工具

sort命令用于将文本文件内容加以排序：
sort file1 file2 #排序两个文件的内容
sort file1 file2 | uniq  #取出两个文件的并集（重复的行只保留一份）
sort file1 file2 | uniq - u  #删除交集，留下其他的行
sort file1 file2 | uniq -d #取出两个文件的交集（只留下同时存在于这两个文件中的文件

uniq
grep 

sed 
Linux sed 命令是利用脚本来处理文本文件,sed 可依照脚本的指令来处理、编辑文本文件。

主要用来自动编辑一个或多个文件、简化对文件的反复操作、编写转换程序等。
sed -i 's/beitihuan/tihuan/ file #替换



awk
awk所有的操作都是基于pattern(模式)—action(动作)对来完成的，如下面的形式：
pattern {action}
它将所有的动作操作用一对{}花括号包围起来。其中pattern通常是表示用于匹配输入的文本的“关系式”或“正则表达式”，action则是表示匹配后将执行的动作。在一个完整awk操作中，这两者可以只有其中一个，如果没有pattern则默认匹配输入的全部文本，如果没有action则默认为打印匹配内容到屏幕。


硬链接 
一般情况下，文件名和inode号码是"一一对应"关系，每个inode号码对应一个文件名。但是，Unix/Linux系统允许，多个文件名指向同一个inode号码。这意味着，可以用不同的文件名访问同样的内容；对文件内容进行修改，会影响到所有文件名；但是，删除一个文件名，不影响另一个文件名的访问。这种情况就被称为"硬链接"（hard link）。
 

ln命令可以创建硬链接：
ln 源文件 目标文件
运行上面这条命令以后，源文件与目标文件的inode号码相同，都指向同一个inode。inode信息中有一项叫做"链接数"，记录指向该inode的文件名总数，这时就会增加1。反过来，删除一个文件名，就会使得inode节点中的"链接数"减1。当这个值减到0，表明没有文件名指向这个inode，系统就会回收这个inode号码，以及其所对应block区域。
 
这里顺便说一下目录文件的"链接数"。创建目录时，默认会生成两个目录项："."和".."。前者的inode号码就是当前目录的inode号码，等同于当前目录的"硬链接"；后者的inode号码就是当前目录的父目录的inode号码，等同于父目录的"硬链接"。所以，任何一个目录的"硬链接"总数，总是等于2加上它的子目录总数（含隐藏目录）,这里的2是父目录对其的“硬链接”和当前目录下的".硬链接“。
软链接
除了硬链接以外，还有一种特殊情况。文件A和文件B的inode号码虽然不一样，但是文件A的内容是文件B的路径。读取文件A时，系统会自动将访问者导向文件B。因此，无论打开哪一个文件，最终读取的都是文件B。这时，文件A就称为文件B的"软链接"（soft link）或者"符号链接（symbolic link）。

这意味着，文件A依赖于文件B而存在，如果删除了文件B，打开文件A就会报错："No such file or directory"。这是软链接与硬链接最大的不同：文件A指向文件B的文件名，而不是文件B的inode号码，文件B的inode"链接数"不会因此发生变化。
 
ln -s命令可以创建软链接。
ln -s 源文文件或目录 目标文件或目录
用df -h命令查看了一下磁盘使用情况
用df -i查看了一下/data分区的索引节点(inode)，发现已经用满(IUsed=100%)，导致系统无法创建新目录和文件

sudo su root
su root

rz:上传文件
sz:下载文件



